<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{% block title %}Work Hour Calculator{% endblock %}</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <link rel="icon" href="data:,">
  <meta name="color-scheme" content="light dark">
  <meta name="description" content="Track worked hours with start/end and breaks.">
  <meta name="robots" content="noindex, nofollow">
  <style>
    :root { --page-max: 960px; }
    body { padding-top: 1.5rem; }
    .container-narrow { max-width: var(--page-max); }
    .hours-badge { font-size: 0.95rem; }
    .table thead th { position: sticky; top: 0; background: var(--bs-body-bg); z-index: 1; }
    .card { border-radius: .75rem; }
    .time-input {
      width: 6.5rem;
      min-width: 6.5rem;
      max-width: 7rem;
      flex: 0 0 auto; /* don't stretch */
    }
    .input-group-text.btn-like {
      cursor: pointer;
      padding: .25rem .5rem;
    }
    .icon-btn.btn {
      padding: .25rem .45rem;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .name-input { width: 16rem; max-width: 100%; }
    .date-input { width: 12rem; max-width: 100%; }
    .break-input { width: 6rem; max-width: 100%; flex: 0 0 auto; }
  .form-label { margin-bottom: .25rem; }
    /* Ensure we can absolutely-position proxy inputs inside groups */
    .input-group { position: relative; }
    /* Invisible but present input to anchor native picker near the click */
    .picker-proxy {
      position: absolute;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
      border: 0;
      padding: 0;
      margin: 0;
    }
  </style>
  {% block head_extra %}{% endblock %}
</head>
<body>
  <div class="container container-narrow">
    {% block content %}{% endblock %}
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Confirm delete using data-confirm-name on forms (event delegation)
    document.addEventListener('submit', (e) => {
      const form = e.target;
      if (!(form instanceof HTMLFormElement)) return;
      if (!form.hasAttribute('data-confirm-name')) return;
      const name = form.getAttribute('data-confirm-name') || 'this record';
      if (!confirm(`Delete record for "${name}"? This cannot be undone.`)) {
        e.preventDefault();
      }
    });

    // Remember name in localStorage
    function bindRememberName() {
      const input = document.querySelector('input[name="name"]');
      if (!input) return;
      const KEY = 'whc:name';
      const saved = localStorage.getItem(KEY);
      if (saved && !input.value) input.value = saved;
      input.addEventListener('change', () => localStorage.setItem(KEY, input.value));
      input.addEventListener('blur', () => localStorage.setItem(KEY, input.value));
    }

    // Helpers to set time inputs to current time
    function nowHHMM() {
      const d = new Date();
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return `${hh}:${mm}`;
    }
    // Event delegation for time/date helpers: open-picker and (optional) fill-now
    document.addEventListener('click', (e) => {
      const el = e.target instanceof Element ? e.target.closest('[data-action]') : null;
      if (!el) return;
      const action = el.getAttribute('data-action');
      const targetId = el.getAttribute('data-target');
      if (!action || !targetId) return;
      const target = document.getElementById(targetId);
      if (!target) return;
      if (action === 'fill-now') {
        e.preventDefault();
        target.value = nowHHMM();
        try { target.dispatchEvent(new Event('input', { bubbles: true })); } catch {}
        if (typeof target.focus === 'function') target.focus();
      } else if (action === 'open-picker') {
        e.preventDefault();
        const pickerId = el.getAttribute('data-picker');
        const picker = pickerId ? document.getElementById(pickerId) : null;
        if (picker && typeof picker.showPicker === 'function') {
          try {
            // Prefill picker with current value if valid
            if (target && target.value) {
              const type = picker.getAttribute('type');
              if ((type === 'time' && /^\d{2}:\d{2}$/.test(target.value)) || (type === 'date' && /^\d{4}-\d{2}-\d{2}$/.test(target.value))) {
                picker.value = target.value;
              }
            }
            // Position picker near the clicked element inside its input-group
            const group = el.closest('.input-group');
            const anchor = picker;
            const anchorStyle = anchor.style;
            if (group) {
              const g = group.getBoundingClientRect();
              const c = el.getBoundingClientRect();
              anchorStyle.left = `${Math.round(c.left - g.left)}px`;
              anchorStyle.top = `${Math.round(c.bottom - g.top)}px`;
            } else {
              // fallback to viewport position
              const c = el.getBoundingClientRect();
              anchorStyle.left = `${Math.round(c.left)}px`;
              anchorStyle.top = `${Math.round(c.bottom)}px`;
            }
            picker.showPicker();
            return;
          } catch {}
        }
        // Fallback: try native picker on target if available
        if (typeof target.showPicker === 'function') {
          try { target.showPicker(); return; } catch {}
        }
        // Final fallback: focus target
        if (typeof target.focus === 'function') target.focus();
      }
    });

    // Sync hidden native pickers back to visible text inputs
    function bindPickerSync() {
      document.querySelectorAll('input[data-sync-to]')?.forEach(picker => {
        picker.addEventListener('change', () => {
          const targetId = picker.getAttribute('data-sync-to');
          if (!targetId) return;
          const target = document.getElementById(targetId);
          if (!target) return;
          const type = picker.getAttribute('type');
          // Update display field
          if (type === 'date' && picker.value) {
            // convert yyyy-mm-dd -> dd-mm-yyyy
            const y = picker.value.slice(0,4), m = picker.value.slice(5,7), d = picker.value.slice(8,10);
            target.value = `${d}-${m}-${y}`;
          } else {
            target.value = picker.value || '';
          }
          // If an ISO target is provided, sync it too
          const isoId = picker.getAttribute('data-sync-iso');
          if (isoId) {
            const isoEl = document.getElementById(isoId);
            if (isoEl) isoEl.value = picker.value || '';
          }
          try { target.dispatchEvent(new Event('input', { bubbles: true })); } catch {}
        });
      });
    }

    // Convert dd-mm-yyyy <-> yyyy-mm-dd helpers
    function dmyToIso(str) {
      const m = /^(\d{2})-(\d{2})-(\d{4})$/.exec(str?.trim?.() || '');
      if (!m) return '';
      return `${m[3]}-${m[2]}-${m[1]}`;
    }
    function isoToDmy(str) {
      const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(str?.trim?.() || '');
      if (!m) return '';
      return `${m[3]}-${m[2]}-${m[1]}`;
    }

    // Bind display date inputs to update hidden ISO on typing/blur
    function bindDisplayDateInputs() {
      document.querySelectorAll('input.date-input').forEach(disp => {
        // If it has a sibling hidden ISO input referenced by id in data-sync-iso on the picker
        const group = disp.closest('.input-group');
        if (!group) return;
        const picker = group.querySelector('input[type="date"][data-sync-to]');
        const isoId = picker?.getAttribute('data-sync-iso');
        const isoEl = isoId ? document.getElementById(isoId) : null;
        if (!isoEl) return;
        const sync = () => {
          const iso = dmyToIso(disp.value);
          if (iso) {
            isoEl.value = iso;
            // also keep the hidden picker in sync so opening shows right value
            picker.value = iso;
          }
        };
        disp.addEventListener('change', sync);
        disp.addEventListener('blur', sync);
        // Initialize from ISO if display empty
        if (!disp.value && isoEl.value) disp.value = isoToDmy(isoEl.value);
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      bindRememberName();
      bindPickerSync();
      bindDisplayDateInputs();
    });
  </script>
  {% block body_extra %}{% endblock %}
</body>
</html>
